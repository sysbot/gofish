//
// SPDX-License-Identifier: BSD-3-Clause
//

package redfish

import (
	"encoding/json"
	"reflect"

	"github.com/stmcginnis/gofish/common"
)

// DHCPFallback is
type DHCPFallback string

const (
	// StaticDHCPFallback shall fall back to a static address specified by IPv4StaticAddresses.
	StaticDHCPFallback DHCPFallback = "Static"
	// AutoConfigDHCPFallback shall fall back to an address generated by the implementation.
	AutoConfigDHCPFallback DHCPFallback = "AutoConfig"
	// NoneDHCPFallback shall continue trying to obtain an address without falling back to a fixed address.
	NoneDHCPFallback DHCPFallback = "None"
)

// DHCPv6OperatingMode is
type DHCPv6OperatingMode string

const (
	// StatefulDHCPv6OperatingMode shall operate in stateful mode on this interface. DHCPv6 stateful mode configures
	// addresses, and when it is enabled, stateless mode is also implicitly enabled. Services may replace this value
	// with 'Enabled'.
	StatefulDHCPv6OperatingMode DHCPv6OperatingMode = "Stateful"
	// StatelessDHCPv6OperatingMode shall operate in stateless mode on this interface. DHCPv6 stateless mode allows
	// configuring the interface using DHCP options but does not configure addresses. It is always enabled by default
	// whenever DHCPv6 Stateful mode is also enabled. Services may replace this value with 'Enabled'.
	StatelessDHCPv6OperatingMode DHCPv6OperatingMode = "Stateless"
	// DisabledDHCPv6OperatingMode shall be disabled for this interface.
	DisabledDHCPv6OperatingMode DHCPv6OperatingMode = "Disabled"
	// EnabledDHCPv6OperatingMode shall be enabled for this interface.
	EnabledDHCPv6OperatingMode DHCPv6OperatingMode = "Enabled"
)

// EthernetDeviceType is
type EthernetDeviceType string

const (
	// PhysicalEthernetDeviceType shall indicate a physical traditional network interface.
	PhysicalEthernetDeviceType EthernetDeviceType = "Physical"
	// VirtualEthernetDeviceType shall indicate a network device function has multiple VLANs and is representing one of
	// them as a virtual Ethernet interface. The NetworkDeviceFunction property within Links shall contain the locator
	// for the parent network device function.
	VirtualEthernetDeviceType EthernetDeviceType = "Virtual"
)

// LinkStatus is
type LinkStatus string

const (
	// LinkUpLinkStatus The link is available for communication on this interface.
	LinkUpLinkStatus LinkStatus = "LinkUp"
	// NoLinkLinkStatus No link or connection is detected on this interface.
	NoLinkLinkStatus LinkStatus = "NoLink"
	// LinkDownLinkStatus No link is detected on this interface, but the interface is connected.
	LinkDownLinkStatus LinkStatus = "LinkDown"
)

// TeamMode is
type TeamMode string

const (
	// NoneTeamMode No teaming.
	NoneTeamMode TeamMode = "None"
	// RoundRobinTeamMode Packets are transmitted in sequential order from the teamed interfaces.
	RoundRobinTeamMode TeamMode = "RoundRobin"
	// ActiveBackupTeamMode One interface in the team is active and the others are kept in standby until a failure
	// occurs.
	ActiveBackupTeamMode TeamMode = "ActiveBackup"
	// XORTeamMode Transmitting is determined based upon a hash policy.
	XORTeamMode TeamMode = "XOR"
	// BroadcastTeamMode Packets are transmitted on all interfaces in the team.
	BroadcastTeamMode TeamMode = "Broadcast"
	// IEEE8023adTeamMode The interfaces in the team create an IEEE802.3ad link aggregation group.
	IEEE8023adTeamMode TeamMode = "IEEE802_3ad"
	// AdaptiveTransmitLoadBalancingTeamMode Packets are transmitted based upon the current load of each interface in
	// the team.
	AdaptiveTransmitLoadBalancingTeamMode TeamMode = "AdaptiveTransmitLoadBalancing"
	// AdaptiveLoadBalancingTeamMode Packets are transmitted and received based upon the current load of each interface
	// in the team.
	AdaptiveLoadBalancingTeamMode TeamMode = "AdaptiveLoadBalancing"
)

// DHCPv4Configuration shall describe the configuration of DHCP v4.
type DHCPv4Configuration struct {
	// DHCPEnabled shall indicate whether DHCP v4 is enabled for this Ethernet interface.
	DHCPEnabled bool
	// FallbackAddress shall contain the fallback address method of DHCPv4.
	FallbackAddress DHCPFallback
	// UseDNSServers shall indicate whether the interface uses DHCP v4-supplied DNS servers.
	UseDNSServers bool
	// UseDomainName shall indicate whether the interface uses a DHCP v4-supplied domain name.
	UseDomainName bool
	// UseGateway shall indicate whether the interface uses a DHCP v4-supplied gateway.
	UseGateway bool
	// UseNTPServers shall indicate whether the interface uses DHCP v4-supplied NTP servers.
	UseNTPServers bool
	// UseStaticRoutes shall indicate whether the interface uses a DHCP v4-supplied static routes.
	UseStaticRoutes bool
}

// UnmarshalJSON unmarshals a DHCPv4Configuration object from the raw JSON.
func (dhcpv4configuration *DHCPv4Configuration) UnmarshalJSON(b []byte) error {
	type temp DHCPv4Configuration
	var t struct {
		temp
	}

	err := json.Unmarshal(b, &t)
	if err != nil {
		return err
	}

	*dhcpv4configuration = DHCPv4Configuration(t.temp)

	// Extract the links to other entities for later

	return nil
}

// DHCPv6Configuration shall describe the configuration of DHCP v6.
type DHCPv6Configuration struct {
	// OperatingMode shall control the operating mode of DHCPv6 on this interface.
	OperatingMode DHCPv6OperatingMode
	// UseDNSServers shall indicate whether the interface uses DHCP v6-supplied DNS servers.
	UseDNSServers bool
	// UseDomainName shall indicate whether the interface uses a DHCP v6-supplied domain name.
	UseDomainName bool
	// UseNTPServers shall indicate whether the interface uses DHCP v6-supplied NTP servers.
	UseNTPServers bool
	// UseRapidCommit shall indicate whether the interface uses DHCP v6 rapid commit mode for stateful mode address
	// assignments.
	UseRapidCommit bool
}

// UnmarshalJSON unmarshals a DHCPv6Configuration object from the raw JSON.
func (dhcpv6configuration *DHCPv6Configuration) UnmarshalJSON(b []byte) error {
	type temp DHCPv6Configuration
	var t struct {
		temp
	}

	err := json.Unmarshal(b, &t)
	if err != nil {
		return err
	}

	*dhcpv6configuration = DHCPv6Configuration(t.temp)

	// Extract the links to other entities for later

	return nil
}

// EthernetInterface This resource contains NIC resources as part of the Redfish Specification.
type EthernetInterface struct {
	common.Entity
	// ODataContext is the odata context.
	ODataContext string `json:"@odata.context"`
	// ODataEtag is the odata etag.
	ODataEtag string `json:"@odata.etag"`
	// ODataType is the odata type.
	ODataType string `json:"@odata.type"`
	// Actions shall contain the available actions for this resource.
	Actions string
	// AutoNeg shall indicate whether the speed and duplex are automatically negotiated and configured on this
	// interface.
	AutoNeg bool
	// DHCPv4 shall contain the configuration of DHCP v4.
	DHCPv4 string
	// DHCPv6 shall contain the configuration of DHCP v6.
	DHCPv6 string
	// Description provides a description of this resource.
	Description string
	// EthernetInterfaceType shall contain the type of interface.
	EthernetInterfaceType EthernetDeviceType
	// FQDN shall contain the fully qualified domain name that DNS obtains for this interface.
	FQDN string
	// FullDuplex shall indicate whether full-duplex mode is enabled on the Ethernet connection for this interface.
	FullDuplex bool
	// HostName shall contain DNS host name for this interface.
	HostName string
	// IPv4Addresses shall contain an array of objects that represent the IPv4 connection characteristics currently in
	// use by this interface for any value of AddressOrigin. It is recommended that this property be regarded as read-
	// only with configuration of static addresses performed by updating the values within IPv4StaticAddresses.
	// Services may reject updates to this array for this reason.
	IPv4Addresses []IPv4Address
	// IPv4StaticAddresses shall contain an array of objects that represent all IPv4 static addresses assigned to, but
	// not necessarily in use by, this interface. The IPv4Addresses property shall also list the addresses that this
	// interface uses .
	IPv4StaticAddresses []IPv4Address
	// IPv6AddressPolicyTable shall contain an array of objects that represent the RFC6724-defined address selection
	// policy table.
	IPv6AddressPolicyTable []IPv6AddressPolicyEntry
	// IPv6Addresses shall contain an array of objects that represent the IPv6 connection characteristics for this
	// interface for any value of AddressOrigin.
	IPv6Addresses []IPv6Address
	// IPv6DefaultGateway shall contain the current IPv6 default gateway address in use on this interface.
	IPv6DefaultGateway string
	// IPv6StaticAddresses shall contain an array of objects that represent the IPv6 static connection characteristics
	// for this interface.
	IPv6StaticAddresses []IPv6StaticAddress
	// IPv6StaticDefaultGateways shall represent the IPv6 static default gateway addresses for this interface.
	IPv6StaticDefaultGateways []IPv6GatewayStaticAddress
	// InterfaceEnabled shall indicate whether this interface is enabled.
	InterfaceEnabled bool
	// LinkStatus shall contain the link status of this interface, or port.
	LinkStatus LinkStatus
	// Links shall contain links to resources that are related to but are not contained by, or subordinate to, this
	// resource.
	Links string
	// MACAddress shall contain the effective current MAC address of this interface. If an assignable MAC address is
	// not supported, this value is a read-only alias of the PermanentMACAddress.
	MACAddress MACAddress
	// MTUSize shall contain the size, in bytes, of largest protocol data unit (PDU) that can be passed in an Ethernet
	// (MAC) frame on this interface.
	MTUSize int
	// MaxIPv6StaticAddresses shall indicate the number of array items supported by IPv6StaticAddresses, or the maximum
	// number of static IPv6 addresses that can be configured on this interface.
	MaxIPv6StaticAddresses int
	// NameServers shall contain the DNS servers in use on this interface.
	NameServers []string
	// Oem shall contain the OEM extensions. All values for properties that this object contains shall conform to the
	// Redfish Specification-described requirements.
	OEM json.RawMessage `json:"Oem"`
	// PermanentMACAddress shall contain the permanent MAC address of this interface, or port. Typically, this value is
	// programmed during manufacturing. This address is not assignable.
	PermanentMACAddress MACAddress
	// SpeedMbps shall contain the link speed of the interface, in Mbit/s. This property shall be writable only when
	// the AutoNeg property is 'false'.
	SpeedMbps int
	// StatelessAddressAutoConfig shall contain the IPv4 and IPv6 stateless address automatic configuration (SLAAC)
	// properties for this interface.
	StatelessAddressAutoConfig string
	// StaticNameServers shall contain the statically-defined set of DNS server IP addresses to use when DHCP
	// provisioning is not enabled for name server configuration. As an implementation option, they can be used in
	// addition to DHCP-provided addresses, or in cases where the DHCP server provides no DNS assignments.
	StaticNameServers []string
	// Status shall contain any status or health properties of the resource.
	Status common.Status
	// TeamMode shall contain the team mode for this interface. If this property is not present, the value shall be
	// assumed to be 'None'.
	TeamMode TeamMode
	// UefiDevicePath shall contain the UEFI device path to the device that implements this interface, or port.
	UefiDevicePath string
	// VLAN shall contain the VLAN for this interface. If this interface supports more than one VLAN, the VLAN property
	// shall be absent and, instead, the VLAN collection link shall be present.
	VLAN string
	// rawData holds the original serialized JSON so we can compare updates.
	rawData []byte
}

// UnmarshalJSON unmarshals a EthernetInterface object from the raw JSON.
func (ethernetinterface *EthernetInterface) UnmarshalJSON(b []byte) error {
	type temp EthernetInterface
	var t struct {
		temp
	}

	err := json.Unmarshal(b, &t)
	if err != nil {
		return err
	}

	*ethernetinterface = EthernetInterface(t.temp)

	// Extract the links to other entities for later

	// This is a read/write object, so we need to save the raw object data for later
	ethernetinterface.rawData = b

	return nil
}

// Update commits updates to this object's properties to the running system.
func (ethernetinterface *EthernetInterface) Update() error {

	// Get a representation of the object's original state so we can find what
	// to update.
	original := new(EthernetInterface)
	original.UnmarshalJSON(ethernetinterface.rawData)

	readWriteFields := []string{
		"AutoNeg",
		"FQDN",
		"FullDuplex",
		"HostName",
		"InterfaceEnabled",
		"MACAddress",
		"MTUSize",
		"SpeedMbps",
		"StaticNameServers",
		"TeamMode",
	}

	originalElement := reflect.ValueOf(original).Elem()
	currentElement := reflect.ValueOf(ethernetinterface).Elem()

	return ethernetinterface.Entity.Update(originalElement, currentElement, readWriteFields)
}

// GetEthernetInterface will get a EthernetInterface instance from the service.
func GetEthernetInterface(c common.Client, uri string) (*EthernetInterface, error) {
	resp, err := c.Get(uri)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var ethernetinterface EthernetInterface
	err = json.NewDecoder(resp.Body).Decode(&ethernetinterface)
	if err != nil {
		return nil, err
	}

	ethernetinterface.SetClient(c)
	return &ethernetinterface, nil
}

// ListReferencedEthernetInterfaces gets the collection of EthernetInterface from
// a provided reference.
func ListReferencedEthernetInterfaces(c common.Client, link string) ([]*EthernetInterface, error) {
	var result []*EthernetInterface
	if link == "" {
		return result, nil
	}

	links, err := common.GetCollection(c, link)
	if err != nil {
		return result, err
	}

	collectionError := common.NewCollectionError()
	for _, ethernetinterfaceLink := range links.ItemLinks {
		ethernetinterface, err := GetEthernetInterface(c, ethernetinterfaceLink)
		if err != nil {
			collectionError.Failures[ethernetinterfaceLink] = err
		} else {
			result = append(result, ethernetinterface)
		}
	}

	if collectionError.Empty() {
		return result, nil
	} else {
		return result, collectionError
	}
}

// IPv6AddressPolicyEntry shall describe an entry in the RFC6724-defined address selection policy table.
type IPv6AddressPolicyEntry struct {
	// Label shall contain the IPv6 label value for this table entry, as defined in RFC6724, section 2.1.
	Label int
	// Precedence shall contain the IPv6 precedence value for this table entry, as defined in RFC6724, section 2.1.
	Precedence int
	// Prefix shall contain the IPv6 address prefix for this table entry, as defined in RFC6724, section 2.1.
	Prefix string
}

// UnmarshalJSON unmarshals a IPv6AddressPolicyEntry object from the raw JSON.
func (ipv6addresspolicyentry *IPv6AddressPolicyEntry) UnmarshalJSON(b []byte) error {
	type temp IPv6AddressPolicyEntry
	var t struct {
		temp
	}

	err := json.Unmarshal(b, &t)
	if err != nil {
		return err
	}

	*ipv6addresspolicyentry = IPv6AddressPolicyEntry(t.temp)

	// Extract the links to other entities for later

	return nil
}

// Links shall contain links to resources that are related to but are not contained by, or subordinate to, this
// resource.
type Links struct {
	// Chassis shall contain a link to a resource of type Chassis that represent the physical container associated with
	// this Ethernet interface.
	Chassis string
	// Endpoints shall contain an array of links to resources of type Endpoint with which this Ethernet interface is
	// associated.
	Endpoints []Endpoint
	// Endpoints@odata.count
	EndpointsCount int `json:"Endpoints@odata.count"`
	// HostInterface shall contain a link to a resource of type HostInterface that represents the interface that a host
	// uses to communicate with a manager.
	HostInterface string
	// NetworkDeviceFunctions shall contain an array of links to resources of type NetworkDeviceFunction.
	NetworkDeviceFunctions []NetworkDeviceFunction
	// NetworkDeviceFunctions@odata.count
	NetworkDeviceFunctionsCount int `json:"NetworkDeviceFunctions@odata.count"`
	// Oem shall contain the OEM extensions. All values for properties contained in this object shall conform to the
	// Redfish Specification-described requirements.
	OEM json.RawMessage `json:"Oem"`
	// Ports shall contain an array of links to resources of type Port that represent the ports providing this Ethernet
	// interface. This property shall not be present if the Ethernet interface is not directly associated to a physical
	// port.
	Ports []Port
	// Ports@odata.count
	PortsCount int `json:"Ports@odata.count"`
	// RelatedInterfaces shall contain an array of links to resources of type EthernetInterface. If TeamMode contains
	// 'None', this property shall contain one member that represents the parent interface for the VLAN. For other
	// values of TeamMode, this property shall contain the members of the team.
	RelatedInterfaces []EthernetInterface
	// RelatedInterfaces@odata.count
	RelatedInterfacesCount int `json:"RelatedInterfaces@odata.count"`
}

// UnmarshalJSON unmarshals a Links object from the raw JSON.
func (links *Links) UnmarshalJSON(b []byte) error {
	type temp Links
	var t struct {
		temp
	}

	err := json.Unmarshal(b, &t)
	if err != nil {
		return err
	}

	*links = Links(t.temp)

	// Extract the links to other entities for later

	return nil
}

// OemActions shall contain the available OEM-specific actions for this resource.
type OemActions struct {
}

// UnmarshalJSON unmarshals a OemActions object from the raw JSON.
func (oemactions *OemActions) UnmarshalJSON(b []byte) error {
	type temp OemActions
	var t struct {
		temp
	}

	err := json.Unmarshal(b, &t)
	if err != nil {
		return err
	}

	*oemactions = OemActions(t.temp)

	// Extract the links to other entities for later

	return nil
}

// StatelessAddressAutoConfiguration shall describe the IPv4 and IPv6 stateless address autoconfiguration (SLAAC)
// for this interface.
type StatelessAddressAutoConfiguration struct {
	// IPv4AutoConfigEnabled shall indicate whether IPv4 stateless address autoconfiguration (SLAAC) is enabled for
	// this interface.
	IPv4AutoConfigEnabled bool
	// IPv6AutoConfigEnabled shall indicate whether IPv6 stateless address autoconfiguration (SLAAC) is enabled for
	// this interface.
	IPv6AutoConfigEnabled bool
}

// UnmarshalJSON unmarshals a StatelessAddressAutoConfiguration object from the raw JSON.
func (statelessaddressautoconfiguration *StatelessAddressAutoConfiguration) UnmarshalJSON(b []byte) error {
	type temp StatelessAddressAutoConfiguration
	var t struct {
		temp
	}

	err := json.Unmarshal(b, &t)
	if err != nil {
		return err
	}

	*statelessaddressautoconfiguration = StatelessAddressAutoConfiguration(t.temp)

	// Extract the links to other entities for later

	return nil
}
